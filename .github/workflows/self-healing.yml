name: Self-Healing Pipeline

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed

permissions:
  contents: read

jobs:
  analyze-failure:
    name: Analyze CI Failure
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    permissions:
      contents: write
      pull-requests: write
      actions: read

    outputs:
      should_attempt_fix: ${{ steps.check-attempts.outputs.should_attempt }}
      attempt_count: ${{ steps.check-attempts.outputs.attempt_count }}
      branch: ${{ steps.get-branch.outputs.branch }}
      pr_number: ${{ steps.get-branch.outputs.pr_number }}

    steps:
      - name: Get branch information
        id: get-branch
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.payload.workflow_run.id;
            const headBranch = context.payload.workflow_run.head_branch;
            const headSha = context.payload.workflow_run.head_sha;
            const pullRequests = context.payload.workflow_run.pull_requests || [];

            console.log(`Failed workflow run: ${runId}`);
            console.log(`Head branch (from workflow_run): ${headBranch}`);
            console.log(`Commit: ${headSha}`);
            console.log(`Associated PRs: ${pullRequests.length}`);

            // Prefer the PR head ref over head_branch, since head_branch
            // can resolve to "main" for PR-triggered CI runs.
            let branch = headBranch;
            let prNumber = '';

            if (pullRequests.length > 0) {
              const pr = pullRequests[0];
              branch = pr.head.ref;
              prNumber = String(pr.number);
              console.log(`PR #${prNumber} detected, using head ref: ${branch}`);
            } else {
              console.log(`No associated PRs â€” using head_branch: ${branch}`);
            }

            core.setOutput('branch', branch);
            core.setOutput('sha', headSha);
            core.setOutput('run_id', runId);
            core.setOutput('pr_number', prNumber);

      - name: Check self-healing attempts
        id: check-attempts
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ steps.get-branch.outputs.branch }}';
            const maxAttempts = 3;

            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: branch,
              per_page: 10
            });

            let attemptCount = 0;
            for (const commit of commits) {
              if (commit.commit.message.includes('[jules-fix]') ||
                  commit.commit.message.includes('[self-healing]')) {
                attemptCount++;
              }
            }

            console.log(`Self-healing attempts on ${branch}: ${attemptCount}/${maxAttempts}`);

            const shouldAttempt = attemptCount < maxAttempts;
            core.setOutput('should_attempt', shouldAttempt);
            core.setOutput('attempt_count', attemptCount);

  jules-fix:
    name: Jules Auto-Fix
    runs-on: ubuntu-latest
    needs: [analyze-failure]
    if: needs.analyze-failure.outputs.should_attempt_fix == 'true'
    permissions:
      contents: write
      pull-requests: write
      actions: read
      checks: read

    steps:
      - name: Fetch and parse CI logs
        id: get-logs
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const runId = context.payload.workflow_run.id;

            // â”€â”€ 1. Collect failed jobs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
            });

            const failedJobs = jobsData.jobs.filter(j => j.conclusion === 'failure');

            if (failedJobs.length === 0) {
              fs.writeFileSync('error_context.txt', 'No failed jobs found in the CI run.');
              core.info('No failed jobs â€” nothing to parse.');
              return;
            }

            const sections = [];

            for (const job of failedJobs) {
              // List the specific steps that failed for quick orientation
              const failedSteps = (job.steps || [])
                .filter(s => s.conclusion === 'failure')
                .map(s => `  - Step "${s.name}" failed`)
                .join('\n');

              let logExcerpt = '';

              try {
                const { data: rawLog } = await github.rest.actions.downloadJobLogsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  job_id: job.id,
                });

                // Strip ANSI escape codes and timestamp prefixes
                const clean = rawLog
                  .replace(/\x1b\[[0-9;]*m/g, '')
                  .replace(/^\d{4}-\d{2}-\d{2}T[\d:.]+Z /gm, '');

                const lines = clean.split('\n');

                // Patterns that indicate real errors
                const errorRe = /\b(error\b|ERR!|FAIL(?:ED|URE)?|TypeError|ReferenceError|SyntaxError|Cannot find|Module not found|not found|unexpected token|failed to compile|exit code [1-9]|AssertionError|assert\.|Expected|Received|ENOENT|EACCES)/i;
                // Patterns that are noise even when they contain "error"
                const noiseRe = /^(\s*npm warn|warning:|0 error|0 failure|passing|info |notice |deprecated)/i;

                // Collect indices of error lines + surrounding context
                // (2 lines before, 5 lines after each match)
                const errorIndices = new Set();
                lines.forEach((line, i) => {
                  if (errorRe.test(line) && !noiseRe.test(line.trim())) {
                    for (let j = Math.max(0, i - 2); j <= Math.min(lines.length - 1, i + 5); j++) {
                      errorIndices.add(j);
                    }
                  }
                });

                if (errorIndices.size > 0) {
                  const sorted = [...errorIndices].sort((a, b) => a - b);
                  const excerptLines = [];
                  let prev = -2;
                  for (const idx of sorted) {
                    if (idx > prev + 1) excerptLines.push('...');
                    excerptLines.push(lines[idx]);
                    prev = idx;
                  }
                  logExcerpt = excerptLines.join('\n');
                } else {
                  // Fallback: last 40 lines of the log
                  logExcerpt = lines.slice(-40).join('\n');
                }
              } catch (e) {
                logExcerpt = `(Could not download logs: ${e.message})`;
              }

              sections.push(
                `### Job: ${job.name}\n${failedSteps}\n\`\`\`\n${logExcerpt}\n\`\`\``
              );
            }

            // â”€â”€ 2. Supplement with check-run annotations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            try {
              const sha = context.payload.workflow_run.head_sha;
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: sha,
                status: 'completed',
                filter: 'latest',
              });

              const failedChecks = checkRuns.check_runs.filter(
                cr => cr.conclusion === 'failure'
              );

              for (const cr of failedChecks) {
                const { data: anns } = await github.rest.checks.listAnnotations({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  check_run_id: cr.id,
                });

                const failures = anns
                  .filter(a => a.annotation_level === 'failure')
                  .slice(0, 10)
                  .map(a => `- ${a.path}:${a.start_line}: ${a.message}`)
                  .join('\n');

                if (failures) {
                  sections.push(`### Annotations (${cr.name})\n${failures}`);
                }
              }
            } catch (_) {
              // Annotations are supplementary â€” do not fail the step
            }

            // â”€â”€ 3. Write to file to avoid output-size limits â”€â”€â”€â”€â”€â”€â”€â”€
            let errorContext = sections.join('\n\n');
            if (errorContext.length > 4000) {
              errorContext = errorContext.slice(0, 3950) + '\n...(truncated)';
            }
            fs.writeFileSync('error_context.txt', errorContext);
            core.info(`Wrote ${errorContext.length} chars of error context`);

      - name: Trigger Jules to fix CI failure
        id: jules-fix
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
          BRANCH: ${{ needs.analyze-failure.outputs.branch }}
          ATTEMPT: ${{ needs.analyze-failure.outputs.attempt_count }}
          REPO: ${{ github.repository }}
        run: |
          echo "Triggering Jules to fix CI failure..."
          echo "Branch: $BRANCH"
          NEXT_ATTEMPT=$((ATTEMPT + 1))
          echo "Attempt: ${NEXT_ATTEMPT}/3"

          # Fallback if the log-fetch step produced no file
          if [ ! -f error_context.txt ]; then
            echo "Could not retrieve CI error logs." > error_context.txt
          fi

          # Build JSON payload with jq --rawfile so all special characters
          # (quotes, backslashes, newlines) are properly escaped.
          PAYLOAD=$(jq -n \
            --rawfile error_ctx error_context.txt \
            --arg branch "$BRANCH" \
            --arg repo "$REPO" \
            --arg title "[jules-fix] Fix CI failure (attempt ${NEXT_ATTEMPT}/3)" \
            '{
              prompt: (
                "CI pipeline has failed. Fix the errors and make the build pass.\n\n"
                + "## Error Context\n" + $error_ctx + "\n\n"
                + "## Instructions\n"
                + "1. Analyze the error logs above\n"
                + "2. Identify the root cause\n"
                + "3. Fix the code\n"
                + "4. Ensure tests pass\n"
                + "5. Ensure linting passes\n\n"
                + "Keep changes minimal and focused on the immediate failure."
              ),
              sourceContext: {
                source: ("sources/github/" + $repo),
                githubRepoContext: { startingBranch: $branch }
              },
              automationMode: "AUTO_CREATE_PR",
              title: $title,
              requirePlanApproval: false
            }')

          RESPONSE=$(curl -s -X POST \
            "https://jules.googleapis.com/v1alpha/sessions" \
            -H "X-Goog-Api-Key: $JULES_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          echo "Jules response: $RESPONSE"

          SESSION_ID=$(echo "$RESPONSE" | jq -r '.name // empty')

          if [ -n "$SESSION_ID" ]; then
            echo "session_id=$SESSION_ID" >> $GITHUB_OUTPUT
            echo "success=true" >> $GITHUB_OUTPUT
            echo "Jules session created: $SESSION_ID"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            ERROR=$(echo "$RESPONSE" | jq -r '.error.message // "Unknown error"')
            echo "error=$ERROR" >> $GITHUB_OUTPUT
            echo "Failed to create Jules session: $ERROR"
          fi

      - name: Wait for Jules
        if: steps.jules-fix.outputs.success == 'true'
        env:
          JULES_API_KEY: ${{ secrets.JULES_API_KEY }}
          SESSION_ID: ${{ steps.jules-fix.outputs.session_id }}
        run: |
          echo "Waiting for Jules to complete fix..."

          for i in {1..60}; do
            RESPONSE=$(curl -s \
              "https://jules.googleapis.com/v1alpha/$SESSION_ID" \
              -H "X-Goog-Api-Key: $JULES_API_KEY")

            STATUS=$(echo "$RESPONSE" | jq -r '.state // "UNKNOWN"')
            echo "Status: $STATUS (check $i/60)"

            if [ "$STATUS" = "COMPLETED" ]; then
              echo "Jules completed the fix!"
              break
            elif [ "$STATUS" = "FAILED" ]; then
              echo "Jules failed to fix the issue"
              break
            fi

            sleep 10
          done

      - name: Post status comment
        uses: actions/github-script@v7
        env:
          JULES_SUCCESS: ${{ steps.jules-fix.outputs.success }}
          JULES_ERROR: ${{ steps.jules-fix.outputs.error }}
          SESSION_ID: ${{ steps.jules-fix.outputs.session_id }}
          ATTEMPT: ${{ needs.analyze-failure.outputs.attempt_count }}
          PR_NUMBER: ${{ needs.analyze-failure.outputs.pr_number }}
        with:
          script: |
            const branch = '${{ needs.analyze-failure.outputs.branch }}';
            const success = process.env.JULES_SUCCESS === 'true';
            const sessionId = process.env.SESSION_ID;
            const error = process.env.JULES_ERROR;
            const attempt = parseInt(process.env.ATTEMPT) + 1;
            const prNumberFromRun = process.env.PR_NUMBER;

            // Use PR number from workflow_run.pull_requests if available,
            // otherwise fall back to searching by branch name.
            let prNumber = null;

            if (prNumberFromRun) {
              prNumber = parseInt(prNumberFromRun, 10);
              console.log(`Using PR #${prNumber} from workflow_run.pull_requests`);
            } else {
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${branch}`,
                state: 'open'
              });

              if (prs.length > 0) {
                prNumber = prs[0].number;
                console.log(`Found PR #${prNumber} by branch search`);
              }
            }

            if (!prNumber) {
              console.log('No open PR found â€” skipping comment');
              return;
            }

            let body;

            if (success) {
              body = [
                '## ðŸ”§ Jules Self-Healing',
                '',
                `**Attempt:** ${attempt}/3`,
                '**Status:** âœ… Jules is working on a fix',
                '',
                `**Session:** \`${sessionId}\``,
                '',
                'Jules has analyzed the CI failure and is implementing a fix. A new PR or commit will be created shortly.',
                '',
                '[View Jules Session](https://jules.google/)',
                '',
                '---',
                '*Powered by [Google Jules](https://jules.google/)*'
              ].join('\n');
            } else {
              body = [
                '## ðŸ”§ Jules Self-Healing',
                '',
                `**Attempt:** ${attempt}/3`,
                '**Status:** âš ï¸ Could not start Jules',
                '',
                `**Error:** ${error || 'Unknown error'}`,
                '',
                'Please check:',
                '1. Jules GitHub App is installed',
                '2. `JULES_API_KEY` secret is configured',
                '3. Repository is connected in Jules',
                '',
                '---',
                '*Powered by [Google Jules](https://jules.google/)*'
              ].join('\n');
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body
            });

  escalate:
    name: Escalate to Human
    runs-on: ubuntu-latest
    needs: analyze-failure
    if: needs.analyze-failure.outputs.should_attempt_fix == 'false'
    permissions:
      issues: write
      pull-requests: write

    steps:
      - name: Create escalation issue
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ needs.analyze-failure.outputs.branch }}';
            const attemptCount = '${{ needs.analyze-failure.outputs.attempt_count }}';
            const prNumberFromRun = '${{ needs.analyze-failure.outputs.pr_number }}';

            // Find the related PR: prefer workflow_run data, fall back to branch search
            let relatedPr = null;

            if (prNumberFromRun) {
              relatedPr = { number: parseInt(prNumberFromRun, 10) };
              console.log(`Using PR #${relatedPr.number} from workflow_run.pull_requests`);
            } else {
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${branch}`,
                state: 'open'
              });
              if (prs.length > 0) {
                relatedPr = prs[0];
                console.log(`Found PR #${relatedPr.number} by branch search`);
              }
            }

            const issueBody = [
              '## Self-Healing Limit Reached',
              '',
              `Jules has made ${attemptCount} attempts to fix CI failures on branch \`${branch}\` without success.`,
              '',
              '**Manual intervention required.**',
              '',
              '### Details',
              `- **Branch:** \`${branch}\``,
              `- **Failed Workflow:** [View Run](${context.payload.workflow_run.html_url})`,
              `- **Jules Attempts:** ${attemptCount}/3`,
              '',
              '### Next Steps',
              '1. Review the failed workflow logs',
              '2. Check Jules sessions at https://jules.google/',
              '3. Apply manual fixes',
              '4. Push changes to trigger CI',
              '',
              relatedPr ? `### Related PR\n- #${relatedPr.number}` : '',
              '',
              '---',
              '*Created by self-healing pipeline*'
            ].join('\n');

            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ CI Failure: Jules exhausted attempts on ${branch}`,
              body: issueBody,
              labels: ['ci-failure', 'needs-attention']
            });

            console.log(`Created escalation issue #${issue.number}`);

            if (relatedPr) {
              const commentBody = [
                '## ðŸš¨ Jules Self-Healing Exhausted',
                '',
                `Jules has made ${attemptCount}/3 fix attempts without success.`,
                '',
                '**Manual intervention required.**',
                '',
                `Escalation issue: #${issue.number}`
              ].join('\n');

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: relatedPr.number,
                body: commentBody
              });
            }
