name: Self-Healing Pipeline

on:
  workflow_run:
    workflows: ["CI", "Build", "Test"]  # Adjust to match your CI workflow names
    types:
      - completed

# Minimal permissions by default
permissions:
  contents: read

jobs:
  analyze-failure:
    name: Analyze CI Failure
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    permissions:
      contents: write
      pull-requests: write
      actions: read

    outputs:
      should_attempt_fix: ${{ steps.check-attempts.outputs.should_attempt }}
      attempt_count: ${{ steps.check-attempts.outputs.attempt_count }}
      branch: ${{ steps.get-branch.outputs.branch }}

    steps:
      - name: Get branch information
        id: get-branch
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.payload.workflow_run.id;
            const headBranch = context.payload.workflow_run.head_branch;
            const headSha = context.payload.workflow_run.head_sha;

            console.log(`Failed workflow run: ${runId}`);
            console.log(`Branch: ${headBranch}`);
            console.log(`Commit: ${headSha}`);

            core.setOutput('branch', headBranch);
            core.setOutput('sha', headSha);
            core.setOutput('run_id', runId);

      - name: Check self-healing attempts
        id: check-attempts
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ steps.get-branch.outputs.branch }}';
            const maxAttempts = 3;

            // Check for self-healing commit markers in recent commits
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: branch,
              per_page: 10
            });

            // Count recent self-healing attempts
            let attemptCount = 0;
            for (const commit of commits) {
              if (commit.commit.message.includes('[self-healing]')) {
                attemptCount++;
              }
            }

            console.log(`Self-healing attempts on ${branch}: ${attemptCount}/${maxAttempts}`);

            const shouldAttempt = attemptCount < maxAttempts;
            core.setOutput('should_attempt', shouldAttempt);
            core.setOutput('attempt_count', attemptCount);

            if (!shouldAttempt) {
              console.log('âš ï¸ Max self-healing attempts reached. Manual intervention required.');
            }

  fetch-logs:
    name: Fetch Build Logs
    runs-on: ubuntu-latest
    needs: analyze-failure
    if: needs.analyze-failure.outputs.should_attempt_fix == 'true'
    permissions:
      actions: read

    outputs:
      error_logs: ${{ steps.get-logs.outputs.logs }}
      error_summary: ${{ steps.get-logs.outputs.summary }}

    steps:
      - name: Download workflow logs
        id: get-logs
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.payload.workflow_run.id;

            try {
              // Get workflow run jobs
              const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId
              });

              // Find failed jobs
              const failedJobs = jobs.jobs.filter(job => job.conclusion === 'failure');

              let errorLogs = [];
              let errorSummary = [];

              for (const job of failedJobs) {
                console.log(`Failed job: ${job.name}`);

                // Get job logs
                try {
                  const { data: logs } = await github.rest.actions.downloadJobLogsForWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    job_id: job.id
                  });

                  // Extract error lines (simplified)
                  const logLines = logs.split('\n');
                  const errorLines = logLines.filter(line =>
                    line.toLowerCase().includes('error') ||
                    line.toLowerCase().includes('failed') ||
                    line.toLowerCase().includes('exception')
                  ).slice(-50);  // Last 50 error lines

                  errorLogs.push({
                    job: job.name,
                    errors: errorLines
                  });

                  errorSummary.push(`Job "${job.name}": ${errorLines.length} error lines found`);
                } catch (e) {
                  console.log(`Could not fetch logs for job ${job.id}: ${e.message}`);
                }
              }

              core.setOutput('logs', JSON.stringify(errorLogs));
              core.setOutput('summary', errorSummary.join('\n'));

            } catch (e) {
              console.log(`Error fetching logs: ${e.message}`);
              core.setOutput('logs', '[]');
              core.setOutput('summary', 'Could not fetch error logs');
            }

  attempt-fix:
    name: Attempt Automatic Fix
    runs-on: ubuntu-latest
    needs: [analyze-failure, fetch-logs]
    if: needs.analyze-failure.outputs.should_attempt_fix == 'true'
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.analyze-failure.outputs.branch }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Analyze and fix errors
        id: fix-errors
        uses: actions/github-script@v7
        env:
          ERROR_LOGS: ${{ needs.fetch-logs.outputs.error_logs }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          ATTEMPT_COUNT: ${{ needs.analyze-failure.outputs.attempt_count }}
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            const errorLogs = JSON.parse(process.env.ERROR_LOGS || '[]');
            const attemptCount = parseInt(process.env.ATTEMPT_COUNT) + 1;

            console.log(`Self-healing attempt ${attemptCount}/3`);
            console.log('Error logs:', JSON.stringify(errorLogs, null, 2));

            // Build analysis prompt for Jules
            const analysisPrompt = `
            You are Jules, an AI assistant helping to fix CI/CD failures.

            ## Error Logs
            ${errorLogs.map(log => `
            ### Job: ${log.job}
            \`\`\`
            ${log.errors.join('\n')}
            \`\`\`
            `).join('\n')}

            ## Task
            Analyze the error logs and determine:
            1. What is the root cause of the failure?
            2. Can this be automatically fixed?
            3. If yes, provide the exact fix.

            Respond in JSON format:
            {
              "rootCause": "Description of the issue",
              "canAutoFix": true|false,
              "fixes": [
                {
                  "file": "path/to/file",
                  "action": "modify|create|delete",
                  "content": "new content or patch",
                  "description": "what this fix does"
                }
              ],
              "manualSteps": ["Step 1", "Step 2"] // if canAutoFix is false
            }
            `;

            console.log('Analysis prompt prepared for Jules');

            // Placeholder: In production, call Anthropic API here
            // For now, attempt common fixes

            let fixApplied = false;
            let fixDescription = '';

            // Common fix patterns
            for (const log of errorLogs) {
              const errorText = log.errors.join('\n').toLowerCase();

              // Check for common fixable issues
              if (errorText.includes('lockfile') || errorText.includes('package-lock')) {
                console.log('Detected lockfile issue, attempting npm install');
                try {
                  execSync('npm install', { stdio: 'inherit' });
                  fixApplied = true;
                  fixDescription = 'Regenerated package-lock.json';
                } catch (e) {
                  console.log('npm install failed:', e.message);
                }
              }

              if (errorText.includes('typescript') && errorText.includes('cannot find')) {
                console.log('Detected TypeScript type error');
                // Could attempt to add missing imports
              }

              if (errorText.includes('lint') || errorText.includes('eslint')) {
                console.log('Detected linting error, attempting auto-fix');
                try {
                  execSync('npm run lint -- --fix', { stdio: 'inherit' });
                  fixApplied = true;
                  fixDescription = 'Applied ESLint auto-fixes';
                } catch (e) {
                  console.log('Lint fix failed:', e.message);
                }
              }

              if (errorText.includes('prettier') || errorText.includes('formatting')) {
                console.log('Detected formatting error');
                try {
                  execSync('npm run format', { stdio: 'inherit' });
                  fixApplied = true;
                  fixDescription = 'Applied code formatting';
                } catch (e) {
                  console.log('Format failed:', e.message);
                }
              }
            }

            core.setOutput('fix_applied', fixApplied);
            core.setOutput('fix_description', fixDescription);

      - name: Commit and push fix
        if: steps.fix-errors.outputs.fix_applied == 'true'
        run: |
          git config user.name "Jules Bot"
          git config user.email "jules-bot@example.com"

          # Check if there are changes to commit
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          git add -A
          git commit -m "[self-healing] ${{ steps.fix-errors.outputs.fix_description }}

          Automatic fix attempt ${{ needs.analyze-failure.outputs.attempt_count }}/3
          Triggered by failed workflow run"

          git push origin ${{ needs.analyze-failure.outputs.branch }}
          echo "âœ… Fix committed and pushed"

      - name: Post status comment
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ needs.analyze-failure.outputs.branch }}';
            const fixApplied = '${{ steps.fix-errors.outputs.fix_applied }}' === 'true';
            const fixDescription = '${{ steps.fix-errors.outputs.fix_description }}';
            const attemptCount = parseInt('${{ needs.analyze-failure.outputs.attempt_count }}') + 1;

            // Find associated PR
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open'
            });

            if (prs.length === 0) {
              console.log('No open PR found for this branch');
              return;
            }

            const pr = prs[0];
            let body;

            if (fixApplied) {
              body = `## ðŸ”§ Self-Healing Pipeline

            **Attempt:** ${attemptCount}/3
            **Status:** âœ… Fix Applied

            **Description:** ${fixDescription}

            A new commit has been pushed with automatic fixes. The CI will re-run shortly.

            ---
            *If this fix doesn't resolve the issue, manual intervention may be required.*`;
            } else {
              body = `## ðŸ”§ Self-Healing Pipeline

            **Attempt:** ${attemptCount}/3
            **Status:** âš ï¸ Could not auto-fix

            The self-healing pipeline analyzed the failure but could not determine an automatic fix.

            **Manual intervention required.**

            Please review the [failed workflow run](${context.payload.workflow_run.html_url}) for details.

            ---
            *Remaining auto-fix attempts: ${3 - attemptCount}*`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body
            });

  escalate:
    name: Escalate to Human
    runs-on: ubuntu-latest
    needs: analyze-failure
    if: needs.analyze-failure.outputs.should_attempt_fix == 'false'
    permissions:
      issues: write
      pull-requests: write

    steps:
      - name: Create escalation issue
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ needs.analyze-failure.outputs.branch }}';
            const attemptCount = '${{ needs.analyze-failure.outputs.attempt_count }}';

            // Find associated PR
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open'
            });

            // Create an issue for tracking
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ CI Failure requires manual intervention: ${branch}`,
              body: `## Self-Healing Limit Reached

            The self-healing pipeline has made ${attemptCount} attempts to fix CI failures on branch \`${branch}\` without success.

            **Manual intervention is required.**

            ### Details
            - **Branch:** \`${branch}\`
            - **Failed Workflow:** [View Run](${context.payload.workflow_run.html_url})
            - **Auto-fix Attempts:** ${attemptCount}/3

            ### Next Steps
            1. Review the failed workflow logs
            2. Identify the root cause
            3. Apply manual fixes
            4. Push changes to trigger CI

            ${prs.length > 0 ? `### Related PR\n- #${prs[0].number}` : ''}

            ---
            *This issue was automatically created by the self-healing pipeline.*`,
              labels: ['ci-failure', 'needs-attention']
            });

            console.log(`Created escalation issue #${issue.number}`);

            // Comment on PR if exists
            if (prs.length > 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prs[0].number,
                body: `## ðŸš¨ Self-Healing Limit Reached

            The automatic fix pipeline has exhausted all attempts (${attemptCount}/3).

            **Manual intervention is required.**

            An issue has been created for tracking: #${issue.number}

            Please review the [failed workflow run](${context.payload.workflow_run.html_url}) and apply manual fixes.`
              });
            }
